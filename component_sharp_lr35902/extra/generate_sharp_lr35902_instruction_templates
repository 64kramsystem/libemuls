#!/usr/bin/env ruby

require 'byebug'
require 'English'
require 'shellwords'
require 'json'
require 'open-uri'

module GitHelpers
  extend self

  def restore_files(*files)
    command = "git checkout HEAD -- " + files.map { |file| file.shellescape }.join(" ")
    execute command
  end

  private

  def execute(command)
    success = system(command)

    exit $CHILD_STATUS.exitstatus if !success
  end
end

module FormattingHelpers
  def hex(value)
    "0x%02X" % value
  end
end

module InstructionsData
  include FormattingHelpers

  extend self

  REGISTER_OPERAND_8 = :register_8
  REGISTER_OPERAND_16 = :register_16
  IMMEDIATE_OPERAND_8 = :immediate_8
  IMMEDIATE_OPERAND_16 = :immediate_16

  REMOVED_OPERAND = :removed

  REGISTERS_8B = %w[A B C D E H L]
  REGISTERS_16B = %w[BC DE HL]

  # Base case of testing code for an operation that affects the flags. If there are flags that have a
  # fixed outcome, they're included (autogenerated).
  #
  BASE = :base

  # Code generated is not efficient, in a few ways. This can be optimized, but it's not the scope of
  # this tool.

  # Specifications:
  #
  # ## Predefined data
  #
  # - operation_code:        (optional) if `zf` is set, then a boolean variable called `carry` must be set
  # - transform_opcode_data: (optional) Executed after fetching the opcode data from the JSON; destructive.
  # - testing:               Proc taking (*operands), returns a hash {"flag_type" => {:extra_instruction_bytes, :presets, :expectations}}
  #
  # ## Computed data
  #
  # - instruction_size
  # - flags_data
  # - operand_types:         Array of `OperandType` instances
  #
  # Pan doc groups some instructions that have different operand types together, e.g. `LD r1, r2`,
  # `LD r, n`, `LD r1, (r2)` and so on; this is correct in a way, but we need more a more specific
  # taxonomy, so the families as represented here are more granular.
  #
  INSTRUCTIONS_DATA = {
    "LD r, n" => {
      prefixed: false,
      opcodes: [
        0x06, 0x0E, 0x16, 0x1E, 0x26, 0x2E,
        0x3E
      ],
      operation_code: <<~RUST,
        *register = *immediate;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            expectations: "#{register} => 0x21,"
          }
        }
      }
    },
    # Includes cases where r1 == r2.
    #
    "LD r1, r2" => {
      prefixed: false,
      opcodes: [
        0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x41, 0x42, 0x43, 0x44, 0x45, 0x48,
        0x4A, 0x4B, 0x4C, 0x4D, 0x50, 0x51, 0x53, 0x54, 0x55, 0x58, 0x59, 0x5A,
        0x5C, 0x5D, 0x60, 0x61, 0x62, 0x63, 0x65, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x47, 0x4F, 0x57, 0x5F, 0x67, 0x6F,
        0x7F, 0x40, 0x49, 0x52, 0x5B, 0x64, 0x6D
      ],
      operation_code: <<~RUST,
        *dst_register = unsafe { *src_register };
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: "cpu.#{register2} = 0x21;",
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    # Includes some cases where r1 is part of r2 (HL).
    #
    "LD r1, (r2)" => {
      prefixed: false,
      opcodes: [
        0x46, 0x4E, 0x56, 0x5E, 0x7E, 0x0A, 0x1A, 0x66, 0x6E
      ],
        operation_code: <<~RUST,
          let address = Self::compose_address(*src_register_high, *src_register_low);
          unsafe { *dst_register = internal_ram[address] };
        RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu.#{register2[0]} = 0x0C;
              cpu.#{register2[1]} = 0xAF;
            RUST
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    # Includes some cases where r2 is part of r1 (HL).
    #
    "LD (r1), r2" => {
      prefixed: false,
      opcodes: [
        0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
        0x02, 0x12, 0x77
      ],
      operation_code: <<~RUST,
        let address = Self::compose_address(*dst_register_high, *dst_register_low);
        internal_ram[address] = unsafe { *src_register };
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            # In the cases where r2 is part of r1, an r1 assignment overwrites r2, so that the memory
            # expectation can be kept the same.
            #
            presets: <<~RUST,
              cpu.#{register2} = 0x21;
              cpu.#{register1[0]} = 0x0C;
              cpu.#{register1[1]} = 0xAF;

              let expected_value = cpu.#{register2};
            RUST
            expectations: "mem[0x0CAF] => expected_value,",
          }
        }
      }
    },
    "LD (r), n" => {
      prefixed: false,
      opcodes: [
        0x36
      ],
      operation_code: <<~RUST,
        let address = Self::compose_address(*register_high, *register_low);
        internal_ram[address] = *immediate;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            presets: <<~RUST,
              cpu.#{register[0]} = 0x0C;
              cpu.#{register[1]} = 0xAF;
            RUST
            expectations: "mem[0x0CAF] => 0x21,",
          }
        }
      }
    },
    "LD A, (nn)" => {
      prefixed: false,
      opcodes: [0xFA],
      operation_code: <<~RUST,
        let address = Self::compose_address(*immediate_high, *immediate_low);
        *register = internal_ram[address];
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu.internal_ram[0x0CAF] = 0x21;",
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LD (nn), A" => {
      prefixed: false,
      opcodes: [0xEA],
      operation_code: <<~RUST,
        let address = Self::compose_address(*dst_immediate_high, *dst_immediate_low);
        internal_ram[address] = *register;
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu.A = 0x21;",
            expectations: "mem[0x0CAF] => 0x21,",
          }
        }
      }
    },
    "LDH A, (C)" => {
      prefixed: false,
      opcodes: [0xF2],
      operation_code: <<~RUST,
        let address = 0xFF00 + *src_register as usize;
        *dst_register = internal_ram[address];
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.C = 0x13;
              cpu.internal_ram[0xFF13] = 0x21;
            RUST
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LDH (C), A" => {
      prefixed: false,
      opcodes: [0xE2],
      operation_code: <<~RUST,
        let address = 0xFF00 + *dst_register as usize;
        internal_ram[address] = *src_register;
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.A = 0x21;
              cpu.C = 0x13;
            RUST
            expectations: "mem[0xFF13] => 0x21,",
          }
        }
      }
    },
    "LDD A, (HL)" => {
      prefixed: false,
      opcodes: [0x3A],
      transform_opcode_data: ->(data) do
        # The source data uses "LD", but includes a "decrement" attribute in the operand.
        data["mnemonic"] = "LDD"
      end,
      operation_code: <<~RUST,
        let address = Self::compose_address(*src_register_high, *src_register_low);
        *dst_register = internal_ram[address];

        let (new_value_low, carry) = src_register_low.overflowing_sub(1);
        *src_register_low = new_value_low;

        if carry {
          let (new_value_high, _) = src_register_high.overflowing_sub(1);
          *src_register_high = new_value_high;
        }
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.H = 0x00;
              cpu.L = 0x00;
              cpu.internal_ram[0x0000] = 0x21;
            RUST
            expectations: <<~RUST
              A => 0x21,
              H => 0xFF,
              L => 0xFF,
            RUST
          }
        }
      }
    },
    "LDD (HL), A" => {
      prefixed: false,
      opcodes: [0x32],
      transform_opcode_data: ->(data) do
        # Same considerations as `LDD A, (HL)`
        data["mnemonic"] = "LDD"
      end,
      operation_code: <<~RUST,
        let address = Self::compose_address(*dst_register_high, *dst_register_low);
        internal_ram[address] = *src_register;

        let (new_value_low, carry) = dst_register_low.overflowing_sub(1);
        *dst_register_low = new_value_low;

        if carry {
          let (new_value_high, _) = dst_register_high.overflowing_sub(1);
          *dst_register_high = new_value_high;
        }
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.A = 0x21;
              cpu.H = 0x00;
              cpu.L = 0x00;
            RUST
            expectations: <<~RUST
              H => 0xFF,
              L => 0xFF,
              mem[0x0000] => 0x21,
            RUST
          }
        }
      }
    },
    "LDI A, (HL)" => {
      prefixed: false,
      opcodes: [0x2A],
      transform_opcode_data: ->(data) do
        # Similar considerations as `LDD A, (HL)`
        data["mnemonic"] = "LDI"
      end,
      operation_code: <<~RUST,
        let address = Self::compose_address(*src_register_high, *src_register_low);
        *dst_register = internal_ram[address];

        let (new_value_low, carry) = src_register_low.overflowing_add(1);
        *src_register_low = new_value_low;

        if carry {
          let (new_value_high, _) = src_register_high.overflowing_add(1);
          *src_register_high = new_value_high;
        }
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.H = 0xFF;
              cpu.L = 0xFF;
              cpu.internal_ram[0xFFFF] = 0x21;
            RUST
            expectations: <<~RUST
              A => 0x21,
              H => 0x00,
              L => 0x00,
            RUST
          }
        }
      }
    },
    "LDI (HL), A" => {
      prefixed: false,
      opcodes: [0x22],
      transform_opcode_data: ->(data) do
        # Same considerations as `LDD A, (HL)`
        data["mnemonic"] = "LDI"
      end,
      operation_code: <<~RUST,
        let address = Self::compose_address(*dst_register_high, *dst_register_low);
        internal_ram[address] = *src_register;

        let (new_value_low, carry) = dst_register_low.overflowing_add(1);
        *dst_register_low = new_value_low;

        if carry {
          let (new_value_high, _) = dst_register_high.overflowing_add(1);
          *dst_register_high = new_value_high;
        }
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.A = 0x21;
              cpu.H = 0xFF;
              cpu.L = 0xFF;
            RUST
            expectations: <<~RUST
              H => 0x00,
              L => 0x00,
              mem[0xFFFF] => 0x21,
            RUST
          }
        }
      }
    },
    "INC r" => {
      prefixed: false,
      opcodes: [0x3C, 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C],
      operation_code: <<~RUST,
        let (new_value, carry) = register.overflowing_add(1);
        *register = new_value;

        if new_value & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(register) {
        {
          BASE => {
            presets: "cpu.#{register} = 0x21;",
            expectations: <<~RUST
              #{register} => 0x22,
            RUST
          },
          'Z' => {
            presets: "cpu.#{register} = 0xFF;",
            expectations: <<~RUST
              #{register} => 0x00,
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: "cpu.#{register} = 0x1F;",
            expectations: <<~RUST
              #{register} => 0x20,
              hf => 1,
            RUST
          }
        }
      }
    },
    "INC (HL)" => {
      prefixed: false,
      opcodes: [0x34],
      operation_code: <<~RUST,
        let address = Self::compose_address(*register_high, *register_low);

        let (new_value, carry) = internal_ram[address].overflowing_add(1);
        internal_ram[address] = new_value;

        if new_value & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(_) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x22,
            RUST
          },
          'Z' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0xFF;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x0,
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x1F;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x20,
              hf => 1,
            RUST
          }
        }
      }
    },
    "NOP" => {
      prefixed: false,
      opcodes: [0x00],
      testing: -> {
        {
          BASE => {}
        }
      }
    },
  }
end

# type:     InstructionData::*_OPERAND
# indirect: boolean
#
OperandType = Struct.new(:type, :indirect)

class CpuDecodingTemplateGenerator
  include InstructionsData
  include FormattingHelpers

  def initialize
    @buffer = StringIO.new
  end

  # While the instructions could be decoded algorithmically up to a certain extent, it's not worth
  # the complexity. For example, `PUSH nn` and `INC nn` use different bitmasks for the registers
  # (the 4th argument shares the same bitmask (base + 11), but point to different registers in the
  # two cases).

  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    opcode_hex = "%02X" % opcode
    operand_types = instruction_data.fetch(:operand_types)
    operand_names = opcode_data.fetch("operands").map { |data| data["name"] }

    generate_matcher_line!(opcode_hex, operand_types)
    generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    generate_closure!(opcode_data, opcode_hex)
  end

  def code
    @buffer.string
  end

  private

  # Matcher line. Example:
  #
  #     [0x36, value @ _] => {
  #
  def generate_matcher_line!(opcode_hex, operand_types)
    @buffer.print "            [0x#{opcode_hex}"

    case operand_types.map(&:type)
    when []
      # Nothing
    when [REGISTER_OPERAND_8]
      # Nothing
    when [REGISTER_OPERAND_16]
      # Nothing
    when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_8]
      @buffer.print ", immediate @ _"
    when [REGISTER_OPERAND_8, REGISTER_OPERAND_8]
      # Nothing
    when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_16]
      @buffer.print ", immediate_low @ _, immediate_high @ _"
    when [REGISTER_OPERAND_8, REGISTER_OPERAND_16]
      # Nothing
    when [REGISTER_OPERAND_16, REGISTER_OPERAND_8]
      # Nothing
    when [REGISTER_OPERAND_16, IMMEDIATE_OPERAND_8]
      @buffer.print ", immediate @ _"
    when [IMMEDIATE_OPERAND_16, REGISTER_OPERAND_8]
      @buffer.print ", immediate_low @ _, immediate_high @ _"
    else
      # This is for safety; it's easy to miss a tuple.
      #
      raise "Unrecognized operand types: #{operand_types}"
    end

    @buffer.puts "] => {"
  end

  # Execution method call. Some examples:
  #
  #     Self::execute_LD_r_n(&mut self.PC, &mut self.L, immediate);
  #
  #     let src_register = &self.L as *const u8;
  #     Self::execute_LD_r1_r2(&mut self.PC, &mut self.L, src_register);
  #
  #     Self::execute_INC_n(&mut self.PC, &mut self.A, &mut self.zf, &mut self.nf, &mut self.hf);
  #
  def generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    # Currently used only for raw pointers.
    #
    variable_assignments = []

    operand_params =
      case operand_types.map(&:type)
      when []
        # Nothing
      when [REGISTER_OPERAND_8]
        "&mut self.#{operand_names[0]}"
      when [REGISTER_OPERAND_16]
        register_high, register_low = operand_names[0].chars
        [
          "&self.#{register_high}",
          "&self.#{register_low}",
        ]
      when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_8]
        [
          "&mut self.#{operand_names[0]}",
          "immediate"
        ]
      when [REGISTER_OPERAND_8, REGISTER_OPERAND_8]
        if instruction_data.fetch(:any_shared_register)
          variable_assignments << "let src_register = &self.#{operand_names[1]} as *const u8;"
          source_register_ref = "src_register"
        else
          source_register_ref = "&self.#{operand_names[1]}"
        end

        [
          "&mut self.#{operand_names[0]}",
          source_register_ref,
        ]
      when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_16]
        [
          "&mut self.#{operand_names[0]}",
          "&immediate_high",
          "&immediate_low",
        ]
      when [REGISTER_OPERAND_8, REGISTER_OPERAND_16]
        if instruction_data.fetch(:any_shared_register)
          variable_assignments << "let dst_register = &mut self.#{operand_names[0]} as *mut u8;"
          dest_register_ref = "dst_register"
        else
          dest_register_ref = "&mut self.#{operand_names[0]}"
        end

        src_register_high, src_register_low = operand_names[1].chars

        # The mutable is required for operations that mutate the source, e.g. LDD.
        [
          dest_register_ref,
          "&mut self.#{src_register_high}",
          "&mut self.#{src_register_low}",
        ]
      when [REGISTER_OPERAND_16, REGISTER_OPERAND_8]
        if instruction_data.fetch(:any_shared_register)
          variable_assignments << "let src_register = &mut self.#{operand_names[1]} as *mut u8;"
          src_register_ref = "src_register"
        else
          src_register_ref = "&self.#{operand_names[1]}"
        end

        dst_register_high, dst_register_low = operand_names[0].chars

        # The mutable is required for operations that mutate the source, e.g. LDD.
        [
          "&mut self.#{dst_register_high}",
          "&mut self.#{dst_register_low}",
          src_register_ref
        ]
      when [REGISTER_OPERAND_16, IMMEDIATE_OPERAND_8]
        dst_register_high, dst_register_low = operand_names[0].chars
        [
          "&self.#{dst_register_high}",
          "&self.#{dst_register_low}",
          "immediate"
        ]
      when [IMMEDIATE_OPERAND_16, REGISTER_OPERAND_8]
        [
          "&immediate_high",
          "&immediate_low",
          "&self.#{operand_names[1]}"
        ]
      else
        raise "Unrecognized operand types: #{operand_types}"
      end

    flag_params = instruction_data.fetch(:flags_data).each_with_object([]) do |(flag, state), flag_params|
      case state
      when "0", "1", flag
        flag_params << "&mut self.#{flag.downcase}f"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    variable_assignments.each do |variable_assignment|
      @buffer.puts "                #{variable_assignment}"
    end

    internal_ram_param = \
      if operand_types.empty?
        []
      elsif operand_types[0].indirect
        ["&mut self.internal_ram"]
      elsif operand_types[1]&.indirect
        ["&self.internal_ram"]
      end

    all_execution_params = ["&mut self.PC", *internal_ram_param, *operand_params, *flag_params].join(", ")

    @buffer.puts "                Self::execute_#{opcode_family}(#{all_execution_params});"
  end

  # Closure (cycles and closing brace)
  #
  def generate_closure!(opcode_data, opcode_hex)
    cycles = opcode_data.fetch("cycles")[0] || raise("Missing #{opcode_hex} cycles!")

    @buffer.puts <<-RUST
                #{cycles}
            }
    RUST
  end
end

class CpuExecutionTemplatesGenerator
  include InstructionsData

  def initialize
    @buffer = StringIO.new
  end

  def add_code!(opcode_family, instruction_data)
    generate_method_signature!(opcode_family, instruction_data)
    generate_register_operations!(instruction_data)
    generate_flag_operations!(instruction_data)
    generate_closure!
  end

  def code
    @buffer.string
  end

  private

  # Execution method call. Example:
  #
  #     fn execute_LD_r_n(PC: &mut u16, register: &mut u8, immediate: &u8) {
  #     fn execute_LD_r1_r2(PC: &mut u16, dst_register: &mut u8, src_register: *const u8) {
  #     fn execute_INC_n(PC: &mut u16, register: &mut u8, zf: &mut bool, nf: &mut bool, hf: &mut bool) {
  #
  def generate_method_signature!(opcode_family, instruction_data)
    operand_types = instruction_data.fetch(:operand_types)

    @buffer.print "    fn execute_#{opcode_family}(PC: &mut u16"

    if operand_types[0]&.indirect
      @buffer.print ", internal_ram: &mut [u8]"
    elsif operand_types[1]&.indirect
      @buffer.print ", internal_ram: &[u8]"
    end

    case operand_types.map(&:type)
    when []
      # nothing to add
    when [REGISTER_OPERAND_8]
      @buffer.print ", register: &mut u8"
    when [REGISTER_OPERAND_16]
      @buffer.print ", register_high: &u8, register_low: &u8"
    when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_8]
      @buffer.print ", register: &mut u8, immediate: &u8"
    when [REGISTER_OPERAND_8, REGISTER_OPERAND_8]
      src_register_type = instruction_data.fetch(:any_shared_register) ? "*const u8" : "&u8"
      @buffer.print ", dst_register: &mut u8, src_register: #{src_register_type}"
    when [REGISTER_OPERAND_8, IMMEDIATE_OPERAND_16]
      @buffer.print ", register: &mut u8, immediate_high: &u8, immediate_low: &u8"
    when [REGISTER_OPERAND_8, REGISTER_OPERAND_16]
      dst_register_type = instruction_data.fetch(:any_shared_register) ? "*mut u8" : "&mut u8"
      # See :generate_execution_method_call for note about the mutable sources.
      @buffer.print ", dst_register: #{dst_register_type}, src_register_high: &mut u8, src_register_low: &mut u8"
    when [REGISTER_OPERAND_16, REGISTER_OPERAND_8]
      src_register_type = instruction_data.fetch(:any_shared_register) ? "*const u8" : "&u8"
      # See :generate_execution_method_call for note about the mutable destination.
      @buffer.print ", dst_register_high: &mut u8, dst_register_low: &mut u8, src_register: #{src_register_type}"
    when [REGISTER_OPERAND_16, IMMEDIATE_OPERAND_8]
      @buffer.print ", register_high: &u8, register_low: &u8, immediate: &u8"
    when [IMMEDIATE_OPERAND_16, IMMEDIATE_OPERAND_8]
      @buffer.print ", dst_immediate_high: &u8, dst_immediate_low: &u8, src_immediate: &u8"
    when [IMMEDIATE_OPERAND_16, REGISTER_OPERAND_8]
      @buffer.print ", dst_immediate_high: &u8, dst_immediate_low: &u8, register: &u8"
    else
      raise "Unrecognized operand types: #{operand_types}"
    end

    flags_data = instruction_data.fetch(:flags_data)

    flags_data.each do |flag, state|
      case state
      when "0", "1", flag
        @buffer.print ", #{flag.downcase}f: &mut bool"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    @buffer.puts ") {"
  end

  # Operations involving registers. Example:
  #
  #     *PC += 1;
  #
  #     let (new_value, carry) = operand.overflowing_add(1);
  #     *operand = new_value;
  #
  def generate_register_operations!(instruction_data)
    instruction_size = instruction_data.fetch(:instruction_size)

    @buffer.puts <<-RUST
      *PC += #{instruction_size};

    RUST

    operation_code = instruction_data[:operation_code]

    if operation_code
      operation_code.each_line do |operation_statement|
        if operation_statement.strip.empty?
          @buffer.puts
        else
          @buffer.puts "      #{operation_statement}"
        end
      end
      @buffer.puts
    end
  end

  # Operations involving flags. Example:
  #
  #     if carry {
  #       *zf = true;
  #     }
  #     *nf = false;
  #
  def generate_flag_operations!(instruction_data)
    flags_data = instruction_data.fetch(:flags_data)
    operation_code = instruction_data[:operation_code]

    flags_data.each do |flag, state|
      case state
      when "0"
        @buffer.puts "      *#{flag.downcase}f = false;"
      when "1"
        @buffer.puts "      *#{flag.downcase}f = true;"
      when flag
        if flag == "Z"
          @buffer.puts <<-RUST
      if carry {
        *zf = true;
      }
          RUST
        else
          # Make sure the operation code takes care of it!
          #
          raise "Missing #{opcode_family} #{flag} flag setting!" if operation_code !~ /\*#{flag.downcase}f = /
        end
      when "-"
        # do nothing
      else
        raise "Invalid flag state: #{state}"
      end
    end
  end

  # Closing brace.
  #
  def generate_closure!
    @buffer.puts <<-RUST
    }

    RUST
  end
end

class TestTemplatesGenerator
  include FormattingHelpers
  include InstructionsData

  def initialize
    @buffer = StringIO.new
  end

  # Creates tests with the form:
  #
  #     context "INC A (0x3C)" {
  #         it "without conditional flag modifications" {
  #             // ...
  #         }
  #
  #         it "with flag Z modified" {
  #             // ...
  #         }
  #
  # Originally, for instuctions that don't have conditional flag modifications, the context
  # was not created (the only test would carry that description) , however, this was a headache, and
  # it's perfectly ok to always have a context (from the consistency point of view, it's actually
  # better).
  #
  # The exact naming of the flag concepts is a bit too verbose, so we oversimplify, and use
  # "un/conditional".
  #
  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    generate_header!(opcode, opcode_data, instruction_data)

    generate_unconditional_test!(opcode, opcode_data, instruction_data)
    generate_conditional_test!(opcode, opcode_data, instruction_data)

    generate_closure!(instruction_data)
  end

  def code
    @buffer.string
  end

  private

  # "Header": Context (optional), and main test method.
  #
  # `context`, or `it` depending on flags being changed or not
  #
  def generate_header!(opcode, opcode_data, instruction_data)
    mnemonic = opcode_data.fetch("mnemonic")
    operand_names = opcode_data.fetch("operands")
    operand_types = instruction_data.fetch(:operand_types)

    operands_description = operand_names
      .map { |data| data.fetch("name") }
      .zip(operand_types)
      .map { |name, type| type.indirect ? "(#{name})" : name }
      .join(", ")

    @buffer.print <<-RUST
            context "#{mnemonic} #{operands_description} [#{hex(opcode)}]" {
    RUST
  end

  def generate_unconditional_test!(opcode, opcode_data, instruction_data)
    title = %Q[it "without conditional flag modifications" {]

    flag_data = instruction_data.fetch(:flags_data)

    unconditional_flags = flag_data.select { |_, state| state == "0" || state == "1" }
    boolean = {"0" => "false", "1" => "true"}
    reverse = {"0" => "1", "1" => "0"}

    flags_preset = unconditional_flags.map do |flag, state|
      "cpu.#{flag.downcase}f = #{boolean[reverse[state]]};"
    end

    flag_expectations = unconditional_flags.map do |flag, state|
      "#{flag.downcase}f => #{state},"
    end

    generate_test_body!(opcode, opcode_data, instruction_data, title, BASE, flags_preset, flag_expectations)
  end

  def generate_conditional_test!(opcode, opcode_data, instruction_data)
    flag_data = instruction_data.fetch(:flags_data)

    conditional_flags = flag_data.select { |flag, state| flag == state }

    conditional_flags.each do |flag, state|
      @buffer.puts

      # In this case, the presets/expectations are in the metadata.
      #
      title = %Q[it "with flag #{flag} modified" {]
      flags_preset = []
      flag_expectations = []

      generate_test_body!(opcode, opcode_data, instruction_data, title, flag, flags_preset, flag_expectations)
    end
  end

  def generate_test_body!(opcode, opcode_data, instruction_data, title, flag, flags_preset, flag_expectations)
    @buffer.puts <<-RUST
                #{title}
    RUST

    opcode_operands = opcode_data.fetch("operands").map { |data| data.fetch("name") }
    testing_block = instruction_data.fetch(:testing)

    extra_instruction_bytes, presets, expectations = begin
        testing_block
          .(*opcode_operands)
          .fetch(flag)
          .values_at(:extra_instruction_bytes, :presets, :expectations)
        rescue KeyError
          raise "Flag #{flag} testing metadata not found for opcode #{hex(opcode)}"
        end

    extra_instruction_bytes_str = extra_instruction_bytes.to_a.map { |byte| ", #{hex(byte)}" }.join

    @buffer.puts <<-RUST
                    let instruction_bytes = [#{hex(opcode)}#{extra_instruction_bytes_str}];

    RUST

    presets = "cpu.PC = 0x21;\n#{presets}"

    presets.each_line.map(&:strip).each do |preset_statement|
      if preset_statement.empty?
        @buffer.puts
      else
        @buffer.puts <<-RUST
                    #{preset_statement}
        RUST
      end
    end

    flags_preset.each do |preset_statement|
      @buffer.puts <<-RUST
                    #{preset_statement}
      RUST
    end

    @buffer.puts <<-RUST

                    assert_cpu_execute!(
                        cpu,
                        instruction_bytes,
    RUST

    instruction_size = instruction_data.fetch(:instruction_size)
    start_pc = 0x21
    end_pc = start_pc + instruction_size
    cycles = opcode_data.fetch("cycles")[0]

    pc_expectation = "PC => #{hex(end_pc)},"

    all_expectations = expectations.to_s.lines.push(pc_expectation).concat(flag_expectations)

    # Sorting is mandated by the macro.
    #
    all_expectations = all_expectations.sort_by do |expectation|
      case expectation
      when /^[A-Z]/
        -1
      when /^.f/
        0
      when /^mem/
        1
      else
        raise "Unexpected expectation: #{expectation}"
      end
    end

    all_expectations.each do |expectation|
      @buffer.puts "                        #{expectation}"
    end

    @buffer.puts <<-RUST
                        cycles: #{cycles}
                    );
                }
    RUST
  end

  # Closing brace, with trailing space.
  #
  def generate_closure!(instruction_data)
    @buffer.puts <<-RUST
            }

    RUST
  end
end

class CpuTemplatesGenerator
  include InstructionsData

  OPCODES_ADDRESS = 'https://gbdev.io/gb-opcodes/Opcodes.json'

  DECODING_REPLACEMENT_START_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_START__'
  DECODING_REPLACEMENT_END_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_END__'
  EXECUTION_REPLACEMENT_START_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_START__'
  EXECUTION_REPLACEMENT_END_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_END__'
  TESTS_REPLACEMENT_START_PATTERN = '// __TESTS_REPLACEMENT_START__'
  TESTS_REPLACEMENT_END_PATTERN = '// __TESTS_REPLACEMENT_END__'

  def initialize(opcodes_file, cpu_file, tests_file)
    @opcodes_file = opcodes_file
    @cpu_file = cpu_file
    @tests_file = tests_file
  end

  def execute(only_opcode: nil)
    check_instructions_data
    download_json_page_content if !File.exists?(@opcodes_file)
    json_page_content = find_and_read_json_page_content
    json_data = JSON.parse(json_page_content)
    cpu_decoding_code, cpu_execution_code, tests_code = generate_templates(json_data, only_opcode: only_opcode)
    insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
  end

  def check_instructions_data
    opcodes_count = INSTRUCTIONS_DATA
      .values
      .flat_map { |instruction_data| instruction_data.fetch(:opcodes) }
      .each_with_object({}) { |opcode, count| count[opcode] ||= 0; count[opcode] += 1 } # tally() on Ruby 2.7

    duplicated_opcodes = opcodes_count.select { |_, count| count > 1}

    if duplicated_opcodes.size > 0
      duplicated_opcodes_hex = duplicated_opcodes.keys.map { |opcode| hex(opcode) }
      raise "Found duplicated opcodes!: #{duplicated_opcodes_hex}"
    end
  end

  def download_json_page_content
    page_content = open(OPCODES_ADDRESS).read
    prettified_data = JSON.pretty_generate(JSON.parse(page_content))
    IO.write(@opcodes_file, prettified_data)
  end

  def find_and_read_json_page_content
    IO.read(@opcodes_file)
  end

  # For samples, see the corresponding `.md` document.
  #
  def generate_templates(json_data, only_opcode:)
    decoding_generator = CpuDecodingTemplateGenerator.new
    execution_generator = CpuExecutionTemplatesGenerator.new
    tests_generator = TestTemplatesGenerator.new

    # Instruction data is mutated. Due to the Proc stored, there's no trivial solution to perform a
    # deep clone; since the data is consumed only once, keeping the worklflow simple is an acceptable
    # solution.
    #
    INSTRUCTIONS_DATA.each do |opcode_family, instruction_data|
      opcodes = instruction_data.fetch(:opcodes)

      next if only_opcode && !opcodes.include?(only_opcode)

      opcode_family_encoded = opcode_family
        .gsub(/\((\w+)\)/, 'I\1')               # indirect:        `(HL)` -> `IHL`
        .gsub(/\(\$(\w+) \+ (\w)\)/, 'I_\1_\2') # Indirect+displ.: `($FF00 + C)` -> I_FF00_C
        .gsub(/,? /, "_")

      prefixed_json_entry = instruction_data.fetch(:prefixed) ? "prefixed" : "unprefixed"

      transform_opcode_data = instruction_data[:transform_opcode_data]

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        transform_opcode_data&.(opcode_data)
      end

      # This procedure is essentially a denormalization of the (extra) instruction data.
      #
      extra_instruction_data = check_and_extract_instruction_data_from_opcodes_data(opcodes, json_data, prefixed_json_entry, instruction_data)
      instruction_data.merge!(extra_instruction_data)

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        decoding_generator.add_code!(opcode, opcode_family_encoded, opcode_data, instruction_data)
        tests_generator.add_code!(opcode, opcode_family, opcode_data, instruction_data)
      end

      execution_generator.add_code!(opcode_family_encoded, instruction_data)
    end

    # Remove the trailing empty line, if any.
    #
    [decoding_generator, execution_generator, tests_generator].map { |generator| generator.code.sub(/^\n\Z/, '') }
  end

  def insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
    cpu_file_content = IO.read(@cpu_file)

    new_cpu_file_content = cpu_file_content
      .sub(/^( *#{DECODING_REPLACEMENT_START_PATTERN}\n).*(^ *#{DECODING_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_decoding_code}\\2")
      .sub(/^( *#{EXECUTION_REPLACEMENT_START_PATTERN}\n).*(^ *#{EXECUTION_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_execution_code}\\2")

    IO.write(@cpu_file, new_cpu_file_content)

    tests_file_content = IO.read(@tests_file)

    new_tests_file_content = tests_file_content
      .sub(/^( *#{TESTS_REPLACEMENT_START_PATTERN}\n).*(^ *#{TESTS_REPLACEMENT_END_PATTERN})/m, "\\1#{tests_code}\\2")

    IO.write(@tests_file, new_tests_file_content)
  end

  ##################################################################################################
  # DATA MANIPULATION
  ##################################################################################################

  # Returns {flags_data, instruction_size, operand_types, any_shared_register}.
  #
  def check_and_extract_instruction_data_from_opcodes_data(opcodes, json_data, prefixed_json_entry, instruction_data)
    any_shared_register = false

    all_instruction_data = opcodes.map do |opcode|
      opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

      flags_data = opcode_data.fetch("flags")
      instruction_size = opcode_data.fetch("bytes")
      operands_data = opcode_data.fetch("operands")

      registers_8bit_used, registers_16bit_used = [], []

      operand_types = operands_data.map do |operand_data|
        operand_name = operand_data.fetch("name")

        # WATCH OUT!! The JSON gets the "immediate" metadata wrong; the correct semantic is is the
        # opposite (see https://git.io/JU8JY), and it really refers to the indirection.
        #
        indirect = !operand_data.fetch("immediate")

        case operand_name
        when "d8"
          OperandType.new(IMMEDIATE_OPERAND_8, indirect)
        when "a16"
          OperandType.new(IMMEDIATE_OPERAND_16, indirect)
        when *REGISTERS_8B
          registers_8bit_used << operand_name
          OperandType.new(REGISTER_OPERAND_8, indirect)
        when *REGISTERS_16B
          registers_16bit_used << operand_name
          OperandType.new(REGISTER_OPERAND_16, indirect)
        else
          debugger
          raise("Unsupported operand type for opcode %02X: #{operand_data}" % opcode)
        end
      end

      # St00pid simple logic.
      #
      any_shared_register ||= \
        registers_8bit_used.uniq.size != registers_8bit_used.size ||
        registers_8bit_used.any? { |register_8_bit| registers_16bit_used.any? { |register_16_bit| register_16_bit.include?(register_8_bit) } }

      {
        flags_data: flags_data,
        instruction_size: instruction_size,
        operand_types: operand_types,
      }
    end

    unique_instruction_data = all_instruction_data.uniq

    if unique_instruction_data.size == 1
      unique_instruction_data[0].merge(any_shared_register: any_shared_register)
    else
      debugger
      raise "Instruction data not unique for opcodes set: #{opcodes.map(&method(:hex))}"
    end
  end
end

module CommandlineDecoder
  extend self

  def execute
    if (ARGV & %w[-h --help]).size > 0
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 0
    elsif ARGV.size > 1
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 1
    else
      opcode = ARGV[0]&.hex
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  opcodes_file = File.expand_path("opcodes.json", __dir__)
  cpu_file = File.expand_path("../src/cpu.rs", __dir__)
  tests_file = File.expand_path("../src/cpu_test.rs", __dir__)

  GitHelpers.restore_files(cpu_file, tests_file)

  only_opcode = CommandlineDecoder.execute

  CpuTemplatesGenerator.new(opcodes_file, cpu_file, tests_file).execute(only_opcode: only_opcode)
end
