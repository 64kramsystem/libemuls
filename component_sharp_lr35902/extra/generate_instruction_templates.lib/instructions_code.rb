module InstructionsCode
  # Base case of testing code for an operation that affects the flags. If there are flags that have a
  # fixed outcome, they're included (autogenerated).
  #
  BASE = "base"

  # Code generated is not efficient, in a few ways. This can be optimized, but it's not the scope of
  # this tool.

  # Specifications:
  #
  # ## Predefined data
  #
  # - operation_code:        (optional) if `zf` is set, then a boolean variable called `carry` must be set
  # - testing:               Proc taking (*operands), returns a hash {"flag_type" => {:extra_instruction_bytes, :presets, :expectations}}
  #
  # ## Computed data
  #
  # - instruction_size
  # - flags_data
  #
  INSTRUCTIONS_CODE = {
    "LD r, n" => {
      operation_code: <<~RUST,
        self[dst_register] = *immediate;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            expectations: "#{register} => 0x21,"
          }
        }
      }
    },
    "LD r1, r2" => {
      operation_code: <<~RUST,
        self[dst_register] = self[src_register];
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: "cpu[Reg8::#{register2}] = 0x21;",
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    "LD r1, (rr2)" => {
        operation_code: <<~RUST,
          self[dst_register] = self.internal_ram[self[src_register] as usize];
        RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu[Reg16::#{register2}] = 0x0CAF;
            RUST
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    "LD (rr1), r2" => {
      operation_code: <<~RUST,
        self.internal_ram[self[dst_register] as usize] = self[src_register];
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            # In the cases where r2 is part of r1, an r1 assignment overwrites r2, so that the memory
            # expectation can be kept the same.
            #
            presets: <<~RUST,
              cpu[Reg8::#{register2}] = 0x21;
              cpu[Reg16::#{register1}] = 0x0CAF;

              let expected_value = cpu[Reg8::#{register2}];
            RUST
            expectations: "mem[0x0CAF] => [expected_value],",
          }
        }
      }
    },
    "LD (HL), n" => {
      operation_code: <<~RUST,
        self.internal_ram[self[Reg16::HL] as usize] = *immediate;
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            presets: <<~RUST,
              cpu[Reg16::HL] = 0x0CAF;
            RUST
            expectations: "mem[0x0CAF] => [0x21],",
          }
        }
      }
    },
    "LD A, (nn)" => {
      operation_code: <<~RUST,
        let address = u16::from_le_bytes([*immediate_low, *immediate_high]) as usize;
        self[Reg8::A] = self.internal_ram[address];
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu.internal_ram[0x0CAF] = 0x21;",
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LD (nn), A" => {
      operation_code: <<~RUST,
        let address = u16::from_le_bytes([*immediate_low, *immediate_high]) as usize;
        self.internal_ram[address] = self[Reg8::A];
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu[Reg8::A] = 0x21;",
            expectations: "mem[0x0CAF] => [0x21],",
          }
        }
      }
    },
    "LD A, (C)" => {
      operation_code: <<~RUST,
        let address = 0xFF00 + self[Reg8::C] as usize;
        self[Reg8::A] = self.internal_ram[address];
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg8::C] = 0x13;
              cpu.internal_ram[0xFF13] = 0x21;
            RUST
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LD (C), A" => {
      operation_code: <<~RUST,
        let address = 0xFF00 + self[Reg8::C] as usize;
        self.internal_ram[address] = self[Reg8::A];
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg8::A] = 0x21;
              cpu[Reg8::C] = 0x13;
            RUST
            expectations: "mem[0xFF13] => [0x21],",
          }
        }
      }
    },
    "LDD A, (HL)" => {
      operation_code: <<~RUST,
        self[Reg8::A] = self.internal_ram[self[Reg16::HL] as usize];

        let (new_value, _) = self[Reg16::HL].overflowing_sub(1);
        self[Reg16::HL] = new_value;
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg16::HL] = 0x0000;
              cpu.internal_ram[0x0000] = 0x21;
            RUST
            expectations: <<~RUST
              A => 0x21,
              HL => 0xFFFF,
            RUST
          }
        }
      }
    },
    "LDD (HL), A" => {
      operation_code: <<~RUST,
        self.internal_ram[self[Reg16::HL] as usize] = self[Reg8::A];

        let (new_value, _) = self[Reg16::HL].overflowing_sub(1);
        self[Reg16::HL] = new_value;
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg8::A] = 0x21;
              cpu[Reg16::HL] = 0x0000;
            RUST
            expectations: <<~RUST
              HL => 0xFFFF,
              mem[0x0000] => [0x21],
            RUST
          }
        }
      }
    },
    "LDI A, (HL)" => {
      operation_code: <<~RUST,
        self[Reg8::A] = self.internal_ram[self[Reg16::HL] as usize];

        let (new_value, _) = self[Reg16::HL].overflowing_add(1);
        self[Reg16::HL] = new_value;
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg16::HL] = 0xFFFF;
              cpu.internal_ram[0xFFFF] = 0x21;
            RUST
            expectations: <<~RUST
              A => 0x21,
              HL => 0x0000,
            RUST
          }
        }
      }
    },
    "LDI (HL), A" => {
      operation_code: <<~RUST,
        self.internal_ram[self[Reg16::HL] as usize] = self[Reg8::A];

        let (new_value, _) = self[Reg16::HL].overflowing_add(1);
        self[Reg16::HL] = new_value;
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg8::A] = 0x21;
              cpu[Reg16::HL] = 0xFFFF;
            RUST
            expectations: <<~RUST
              HL => 0x0000,
              mem[0xFFFF] => [0x21],
            RUST
          }
        }
      }
    },
    "LDH (n), A" => {
      operation_code: <<~RUST,
        let address = 0xFF00 + *immediate as usize;
        self.internal_ram[address] = self[Reg8::A];
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0x13],
            presets: <<~RUST,
              cpu[Reg8::A] = 0x21;
            RUST
            expectations: "mem[0xFF13] => [0x21],",
          }
        }
      }
    },
    "LDH A, (n)" => {
      operation_code: <<~RUST,
        let address = 0xFF00 + *immediate as usize;
        self[Reg8::A] = self.internal_ram[address];
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0x13],
            presets: <<~RUST,
              cpu.internal_ram[0xFF13] = 0x21;
            RUST
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LD rr, nn" => {
      operation_code: <<~RUST,
        self[dst_register] = ((*immediate_high as u16) << 8) + *immediate_low as u16;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0xFE, 0xCA],
            expectations: <<~RUST
              #{register} => 0xCAFE,
            RUST
          }
        }
      }
    },
    "LD SP, HL" => {
      operation_code: <<~RUST,
        self[Reg16::SP] = self[Reg16::HL];
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu[Reg16::HL] = 0xCAFE;
            RUST
            expectations: <<~RUST
              SP => 0xCAFE,
            RUST
          }
        }
      }
    },
    "LD (nn), SP" => {
      operation_code: <<~RUST,
        let address = ((*immediate_high as usize) << 8) + *immediate_low as usize;
        self.internal_ram[address] = self[Reg16::SP] as u8;
        self.internal_ram[address + 1] = (self[Reg16::SP] >> 8) as u8;
      RUST
      testing: ->(_) {
        {
          BASE => {
            extra_instruction_bytes: [0xFE, 0xCA],
            presets: <<~RUST,
              cpu[Reg16::SP] = 0xBEEF;
            RUST
            expectations: <<~RUST
              mem[0xCAFE] => [0xEF, 0xBE],
            RUST
          }
        }
      }
    },
    "INC r" => {
      operation_code: <<~RUST,
        let (new_value, carry) = self[dst_register].overflowing_add(1);
        self[dst_register] = new_value;

        if new_value & 0b0000_1111 == 0b000_0000 {
            self[Flag::h] = true;
        }
      RUST
      testing: ->(register) {
        {
          BASE => {
            presets: "cpu[Reg8::#{register}] = 0x21;",
            expectations: <<~RUST
              #{register} => 0x22,
            RUST
          },
          'Z' => {
            presets: "cpu[Reg8::#{register}] = 0xFF;",
            expectations: <<~RUST
              #{register} => 0x00,
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: "cpu[Reg8::#{register}] = 0x1F;",
            expectations: <<~RUST
              #{register} => 0x20,
              hf => 1,
            RUST
          }
        }
      }
    },
    "INC (HL)" => {
      operation_code: <<~RUST,
        let (new_value, carry) = self.internal_ram[self[Reg16::HL] as usize].overflowing_add(1);
        self.internal_ram[self[Reg16::HL] as usize] = new_value;

        if new_value & 0b0000_1111 == 0b000_0000 {
            self[Flag::h] = true;
        }
      RUST
      testing: ->() {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu[Reg16::HL] = 0x0CAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => [0x22],
            RUST
          },
          'Z' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0xFF;
              cpu[Reg16::HL] = 0x0CAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => [0x0],
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x1F;
              cpu[Reg16::HL] = 0x0CAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => [0x20],
              hf => 1,
            RUST
          }
        }
      }
    },
    "NOP" => {
      operation_code: "",
      testing: -> {
        {
          BASE => {
            expectations: ""
          }
        }
      }
    },
  }
end
