#!/usr/bin/env ruby

require 'byebug'
require 'shellwords'
require 'json'
require 'open-uri'

module GitHelpers
  extend self

  def restore_files(*files)
    command = "git checkout HEAD -- " + files.map { |file| file.shellescape }.join(" ")
    execute command
  end

  private

  def execute(command)
    success = system(command)

    exit $CHILD_STATUS.exitstatus if !success
  end
end

module FormattingHelpers
  def hex(value)
    "0x%02X" % value
  end
end

module InstructionsData
  include FormattingHelpers

  extend self

  REGISTER_OPERAND = :register
  IMMEDIATE_OPERAND = :immediate
  INDIRECT_REGISTER_OPERAND = :indirect_register
  INDIRECT_IMMEDIATE_OPERAND = :indirect_immediate
  INDIRECT_IMMEDIATE_REGISTER_OPERAND = :indirect_immediate_register

  REGISTERS_8B = %w[A B C D E H L]
  REGISTERS_16B = %w[BC DE HL]

  # Base case of testing code for an operation that affects the flags. If there are flags that have a
  # fixed outcome, they're included (autogenerated).
  #
  BASE = :base

  # Code generated is not efficient, in a few ways. This can be optimized, but it's not the scope of
  # this tool.

  # Specifications:
  #
  # ## Predefined data
  #
  # - operation_code:        (optional) if `zf` is set, then a boolean variable called `carry` must be set
  # - flags_code:            (optional)
  # - transform_opcode_data: (optional) Executed after fetching the opcode data from the JSON; destructive.
  # - testing:               Proc taking (*operands), returns a hash {"flag_type" => {:extra_instruction_bytes, :presets, :expectations}}
  #
  # ## Computed data
  #
  # - instruction_size
  # - flags_data
  # - operand_types:         Array of REGISTER_OPERAND, IMMEDIATE_OPERAND, INDIRECT_REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND
  #
  # Pan doc groups some instructions that have different operand types together, e.g. `LD r1, r2`,
  # `LD r, n`, `LD r1, (r2)` and so on; this is correct in a way, but we need more a more specific
  # taxonomy, so the families as represented here are more granular.
  #
  INSTRUCTIONS_DATA = {
    "LD r, n" => {
      prefixed: false,
      opcodes: [
        0x06, 0x0E, 0x16, 0x1E, 0x26, 0x2E,
        0x3E
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            expectations: "#{register} => 0x21,"
          }
        }
      }
    },
    "LD r1, r2" => {
      prefixed: false,
      opcodes: [
        0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x41, 0x42, 0x43, 0x44, 0x45, 0x48,
        0x4A, 0x4B, 0x4C, 0x4D, 0x50, 0x51, 0x53, 0x54, 0x55, 0x58, 0x59, 0x5A,
        0x5C, 0x5D, 0x60, 0x61, 0x62, 0x63, 0x65, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x47, 0x4F, 0x57, 0x5F, 0x67, 0x6F
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: "cpu.#{register2} = 0x21;",
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    "LD r1, (r2)" => {
      prefixed: false,
      opcodes: [
        0x46, 0x4E, 0x56, 0x5E, 0x66, 0x6E, 0x7E, 0x0A, 0x1A
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu.#{register2[0]} = 0x0C;
              cpu.#{register2[1]} = 0xAF;
            RUST
            expectations: "#{register1} => 0x21,",
          }
        }
      }
    },
    # Supporting 0x74 and 0x75 (`LD (HL), H/L`) makes the logic a bit more complex (and, for these
    # two cases, part redundant).
    #
    "LD (r1), r2" => {
      prefixed: false,
      opcodes: [
        0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
        0x02, 0x12, 0x77
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register1, register2) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.#{register2} = 0x21;
              cpu.#{register1[0]} = 0x0C;
              cpu.#{register1[1]} = 0xAF;

              let expected_value = cpu.#{register2};
            RUST
            expectations: "mem[0x0CAF] => expected_value,",
          }
        }
      }
    },
    # No-ops. They are troublesome because without special handling, the register variable is
    # simultaneously borrowed as readonly and mutable, causing an error. There isn't a general way
    # of solving this, without introducing conditional logic.
    #
    "LD r, r" => {
      prefixed: false,
      opcodes: [
        0x7F, 0x40, 0x49, 0x52, 0x5B, 0x64, 0x6D
      ],
      transform_opcode_data: ->(data) do
        data.fetch("operands").pop
      end,
      operation_code: <<~RUST,
        *operand = *operand;
      RUST
      testing: ->(register) {
        {
          BASE => {
            presets: "cpu.#{register} = 0x21;",
            expectations: "#{register} => 0x21,",
          }
        }
      }
    },
    "LD (r), n" => {
      prefixed: false,
      opcodes: [
        0x36
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register, _) {
        {
          BASE => {
            extra_instruction_bytes: [0x21],
            presets: <<~RUST,
              cpu.#{register[0]} = 0x0C;
              cpu.#{register[1]} = 0xAF;
            RUST
            expectations: "mem[0x0CAF] => 0x21,",
          }
        }
      }
    },
    "LD A, (nn)" => {
      prefixed: false,
      opcodes: [0xFA],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu.internal_ram[0x0CAF] = 0x21;",
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "LD (nn), A" => {
      prefixed: false,
      opcodes: [0xEA],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            extra_instruction_bytes: [0xAF, 0x0C],
            presets: "cpu.A = 0x21;",
            expectations: "mem[0x0CAF] => 0x21,",
          }
        }
      }
    },
    "LD A, ($FF00 + C)" => {
      prefixed: false,
      opcodes: [0xF2],
      transform_opcode_data: ->(data) do
        data.fetch("operands")[1]["name"] = "FF00 + C"
      end,
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(_, _) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.C = 0x13;
              cpu.internal_ram[0xFF13] = 0x21;
            RUST
            expectations: "A => 0x21,",
          }
        }
      }
    },
    "INC r" => {
      prefixed: false,
      opcodes: [0x3C, 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C],
      operation_code: <<~RUST,
        let (new_value, carry) = operand.overflowing_add(1);
        *operand = new_value;
      RUST
      flags_code: <<~RUST,
        if *operand & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(register) {
        {
          BASE => {
            presets: "cpu.#{register} = 0x21;",
            expectations: <<~RUST
              #{register} => 0x22,
            RUST
          },
          'Z' => {
            presets: "cpu.#{register} = 0xFF;",
            expectations: <<~RUST
              #{register} => 0x00,
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: "cpu.#{register} = 0x1F;",
            expectations: <<~RUST
              #{register} => 0x20,
              hf => 1,
            RUST
          }
        }
      }
    },
    "INC (HL)" => {
      prefixed: false,
      opcodes: [0x34],
      operation_code: <<~RUST,
        let (new_value, carry) = operand.overflowing_add(1);
        *operand = new_value;
      RUST
      flags_code: <<~RUST,
        if *operand & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(_) {
        {
          BASE => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x21;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x22,
            RUST
          },
          'Z' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0xFF;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x0,
              zf => 1,
              hf => 1,
            RUST
          },
          'H' => {
            presets: <<~RUST,
              cpu.internal_ram[0x0CAF] = 0x1F;
              cpu.H = 0x0C;
              cpu.L = 0xAF;
            RUST
            expectations: <<~RUST
              mem[0x0CAF] => 0x20,
              hf => 1,
            RUST
          }
        }
      }
    },
    "NOP" => {
      prefixed: false,
      opcodes: [0x00],
      testing: -> {
        {
          BASE => {}
        }
      }
    },
  }
end

class CpuDecodingTemplateGenerator
  include InstructionsData
  include FormattingHelpers

  def initialize
    @buffer = StringIO.new
  end

  # While the instructions could be decoded algorithmically up to a certain extent, it's not worth
  # the complexity. For example, `PUSH nn` and `INC nn` use different bitmasks for the registers
  # (the 4th argument shares the same bitmask (base + 11), but point to different registers in the
  # two cases).

  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    opcode_hex = "%02X" % opcode
    operand_types = instruction_data.fetch(:operand_types)
    operand_names = opcode_data.fetch("operands").map { |data| data["name"] }

    generate_matcher_line!(opcode_hex, operand_types)
    generate_variable_assignments!(opcode_data, operand_types, operand_names)
    generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    generate_closure!(opcode_data, opcode_hex)
  end

  def code
    @buffer.string
  end

  private

  # Matcher line. Example:
  #
  #     [0x36, value @ _] => {
  #
  def generate_matcher_line!(opcode_hex, operand_types)
    @buffer.print "            [0x#{opcode_hex}"

    case operand_types
    when []
      # Nothing
    when [REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND]
      # Nothing
    when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", value @ _"
    when [REGISTER_OPERAND, REGISTER_OPERAND]
      # Nothing
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
      @buffer.print ", low_byte @ _, high_byte @ _"
    when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", value @ _"
    when [INDIRECT_IMMEDIATE_OPERAND, REGISTER_OPERAND]
      @buffer.print ", low_byte @ _, high_byte @ _"
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_REGISTER_OPERAND]
      # Nothing
    else
      # This is for safety; it's easy to miss a tuple.
      #
      raise "Unrecognized operand types: #{operand_types}"
    end

    @buffer.puts "] => {"
  end

  # Optional variables assigned before invoking the execution code. Example:
  #
  #     let address = Self::compose_address(*high_byte, *low_byte);
  #
  def generate_variable_assignments!(opcode_data, operand_types, operand_names)
    operand_types.each_with_index do |operand_type, i|
      case operand_type
      when INDIRECT_IMMEDIATE_OPERAND
        @buffer.puts "                let address = Self::compose_address(*high_byte, *low_byte);"
        break
      when INDIRECT_REGISTER_OPERAND
        high_byte_register, low_byte_register = operand_names[i].chars
        @buffer.puts "                let address = Self::compose_address(self.#{high_byte_register}, self.#{low_byte_register});"
        break
      end
    end
  end

  # Execution method call. Example:
  #
  #     Self::execute_LD_nn_n(&mut self.PC, &mut self.B, *value);
  #
  def generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    operand_params =
      case operand_types
      when []
        # Nothing
      when [REGISTER_OPERAND]
        "&mut self.#{operand_names[0]}"
      when [INDIRECT_REGISTER_OPERAND]
        "&mut self.internal_ram[address]"
      when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "*value"
        ]
      when [REGISTER_OPERAND, REGISTER_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.#{operand_names[1]}"
        ]
      when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.internal_ram[address]"
        ]
      when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.internal_ram[address]"
        ]
      when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
        [
          "&mut self.internal_ram[address]",
          "self.#{operand_names[1]}"
        ]
      when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
        [
          "&mut self.internal_ram[address]",
          "*value"
        ]
      when [INDIRECT_IMMEDIATE_OPERAND, REGISTER_OPERAND]
        [
          "&mut self.internal_ram[address]",
          "self.#{operand_names[1]}"
        ]
      when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_REGISTER_OPERAND]
        displacement, register = operand_names[1].split(' + ')
        [
          "&mut self.#{operand_names[0]}",
          "self.internal_ram[0x#{displacement} + self.#{register} as usize]",
        ]
      else
        raise "Unrecognized operand types: #{operand_types}"
      end

    flag_params = instruction_data.fetch(:flags_data).each_with_object([]) do |(flag, state), flag_params|
      case state
      when "0", "1", flag
        flag_params << "&mut self.#{flag.downcase}f"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    all_execution_params = ["&mut self.PC", *operand_params, *flag_params].join(", ")

    @buffer.puts "                Self::execute_#{opcode_family}(#{all_execution_params});"
  end

  # Closure (cycles and closing brace)
  #
  def generate_closure!(opcode_data, opcode_hex)
    cycles = opcode_data.fetch("cycles")[0] || raise("Missing #{opcode_hex} cycles!")

    @buffer.puts <<-RUST
                #{cycles}
            }
    RUST
  end
end

class CpuExecutionTemplatesGenerator
  include InstructionsData

  def initialize
    @buffer = StringIO.new
  end

  def add_code!(opcode_family, instruction_data)
    generate_method_signature!(opcode_family, instruction_data)
    generate_register_operations!(instruction_data)
    generate_flag_operations!(instruction_data)
    generate_closure!
  end

  def code
    @buffer.string
  end

  private

  # Execution method call. Example:
  #
  #     fn execute_LD_r_n(PC: &mut u16, operand: &mut u8, value: u8) {
  #
  def generate_method_signature!(opcode_family, instruction_data)
    operand_types = instruction_data.fetch(:operand_types)

    @buffer.print "    fn execute_#{opcode_family}(PC: &mut u16"

    case operand_types
    when []
      # nothing to add
    when [REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8"
    when [INDIRECT_REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8"
    when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_IMMEDIATE_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_IMMEDIATE_OPERAND, REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    else
      raise "Unrecognized operand types: #{operand_types}"
    end

    flags_data = instruction_data.fetch(:flags_data)

    flags_data.each do |flag, state|
      case state
      when "0", "1", flag
        @buffer.print ", #{flag.downcase}f: &mut bool"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    @buffer.puts ") {"
  end

  # Operations involving registers. Example:
  #
  #     *PC += 1;
  #
  #     let (new_value, carry) = operand.overflowing_add(1);
  #     *operand = new_value;
  #
  def generate_register_operations!(instruction_data)
    instruction_size = instruction_data.fetch(:instruction_size)

    @buffer.puts <<-RUST
      *PC += #{instruction_size};

    RUST

    operation_code = instruction_data[:operation_code]

    if operation_code
      operation_code.each_line do |operation_statement|
        @buffer.puts "      #{operation_statement}"
      end
      @buffer.puts
    end
  end

  # Operations involving flags. Example:
  #
  #     if carry {
  #       *zf = true;
  #     }
  #     *nf = false;
  #
  def generate_flag_operations!(instruction_data)
    flags_code = instruction_data[:flags_code]

    if flags_code
      flags_code.each_line do |flag_statement|
        @buffer.print "      #{flag_statement}"
      end
    end

    flags_data = instruction_data.fetch(:flags_data)

    flags_data.each do |flag, state|
      case state
      when "0"
        @buffer.puts "      *#{flag.downcase}f = false;"
      when "1"
        @buffer.puts "      *#{flag.downcase}f = true;"
      when flag
        if flag == "Z"
          @buffer.puts <<-RUST
      if carry {
        *zf = true;
      }
          RUST
        else
          # Make sure the operation code takes care of it!
          #
          raise "Missing #{opcode_family} #{flag} flag setting!" if flags_code !~ /\*#{flag.downcase}f = /
        end
      when "-"
        # do nothing
      else
        raise "Invalid flag state: #{state}"
      end
    end
  end

  # Closing brace.
  #
  def generate_closure!
    @buffer.puts <<-RUST
    }

    RUST
  end
end

class TestTemplatesGenerator
  include FormattingHelpers
  include InstructionsData

  def initialize
    @buffer = StringIO.new
  end

  # Creates tests with the form:
  #
  #     context "INC A (0x3C)" {
  #         it "without conditional flag modifications" {
  #             // ...
  #         }
  #
  #         it "with flag Z modified" {
  #             // ...
  #         }
  #
  # Originally, for instuctions that don't have conditional flag modifications, the context
  # was not created (the only test would carry that description) , however, this was a headache, and
  # it's perfectly ok to always have a context (from the consistency point of view, it's actually
  # better).
  #
  # The exact naming of the flag concepts is a bit too verbose, so we oversimplify, and use
  # "un/conditional".
  #
  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    generate_header!(opcode, opcode_data, instruction_data)

    generate_unconditional_test!(opcode, opcode_data, instruction_data)
    generate_conditional_test!(opcode, opcode_data, instruction_data)

    generate_closure!(instruction_data)
  end

  def code
    @buffer.string
  end

  private

  # "Header": Context (optional), and main test method.
  #
  # `context`, or `it` depending on flags being changed or not
  #
  def generate_header!(opcode, opcode_data, instruction_data)
    mnemonic = opcode_data.fetch("mnemonic")
    operand_names = opcode_data.fetch("operands")
    operand_types = instruction_data.fetch(:operand_types)

    operands_description = operand_names
      .map { |data| data.fetch("name") }
      .zip(operand_types)
      .map { |name, type| type == INDIRECT_REGISTER_OPERAND || type == INDIRECT_IMMEDIATE_OPERAND ? "(#{name})" : name }
      .join(", ")

    @buffer.print <<-RUST
            context "#{mnemonic} #{operands_description} [#{hex(opcode)}]" {
    RUST
  end

  def generate_unconditional_test!(opcode, opcode_data, instruction_data)
    title = %Q[it "without conditional flag modifications" {]

    flag_data = instruction_data.fetch(:flags_data)

    unconditional_flags = flag_data.select { |_, state| state == "0" || state == "1" }
    boolean = {"0" => "false", "1" => "true"}
    reverse = {"0" => "1", "1" => "0"}

    flags_preset = unconditional_flags.map do |flag, state|
      "cpu.#{flag.downcase}f = #{boolean[reverse[state]]};"
    end

    flag_expectations = unconditional_flags.map do |flag, state|
      "#{flag.downcase}f => #{state},"
    end

    generate_test_body!(opcode, opcode_data, instruction_data, title, BASE, flags_preset, flag_expectations)
  end

  def generate_conditional_test!(opcode, opcode_data, instruction_data)
    flag_data = instruction_data.fetch(:flags_data)

    conditional_flags = flag_data.select { |flag, state| flag == state }

    conditional_flags.each do |flag, state|
      @buffer.puts

      # In this case, the presets/expectations are in the metadata.
      #
      title = %Q[it "with flag #{flag} modified" {]
      flags_preset = []
      flag_expectations = []

      generate_test_body!(opcode, opcode_data, instruction_data, title, flag, flags_preset, flag_expectations)
    end
  end

  def generate_test_body!(opcode, opcode_data, instruction_data, title, flag, flags_preset, flag_expectations)
    @buffer.print <<-RUST
                #{title}
    RUST

    opcode_operands = opcode_data.fetch("operands").map { |data| data.fetch("name") }
    testing_block = instruction_data.fetch(:testing)

    extra_instruction_bytes, presets, expectations = begin
        testing_block
          .(*opcode_operands)
          .fetch(flag)
          .values_at(:extra_instruction_bytes, :presets, :expectations)
        rescue KeyError
          raise "Flag #{flag} testing metadata not found for opcode #{hex(opcode)}"
        end

    extra_instruction_bytes_str = extra_instruction_bytes.to_a.map { |byte| ", #{hex(byte)}" }.join

    @buffer.print <<-RUST
                    let instruction_bytes = [#{hex(opcode)}#{extra_instruction_bytes_str}];

    RUST

    presets = "" if presets.nil?
    presets = "cpu.PC = 0x21;\n#{presets}" if presets !~ /\bcpu.PC +=/

    presets.each_line.map(&:strip).each do |preset_statement|
      if preset_statement.empty?
        @buffer.puts
      else
        @buffer.print <<-RUST
                    #{preset_statement}
        RUST
      end
    end

    flags_preset.each do |preset_statement|
      @buffer.print <<-RUST
                    #{preset_statement}
      RUST
    end

    @buffer.print <<-RUST

                    assert_cpu_execute!(
                        cpu,
                        instruction_bytes,
    RUST

    instruction_size = instruction_data.fetch(:instruction_size)
    start_pc = 0x21
    end_pc = start_pc + instruction_size
    cycles = opcode_data.fetch("cycles")[0]

    pc_expectation = "PC => #{hex(end_pc)},"

    all_expectations = expectations.to_s.lines.push(pc_expectation).concat(flag_expectations)

    # Sorting is mandated by the macro.
    #
    all_expectations = all_expectations.sort_by do |expectation|
      case expectation
      when /^[A-Z]/
        -1
      when /^.f/
        0
      when /^mem/
        1
      else
        raise "Unexpected expectation: #{expectation}"
      end
    end

    all_expectations.each do |expectation|
      @buffer.puts "                        #{expectation}"
    end

    @buffer.print <<-RUST
                        cycles: #{cycles}
                    );
                }
    RUST
  end

  # Closing brace, with trailing space.
  #
  def generate_closure!(instruction_data)
    @buffer.puts <<-RUST
            }

    RUST
  end
end

class CpuTemplatesGenerator
  include InstructionsData

  OPCODES_ADDRESS = 'https://gbdev.io/gb-opcodes/Opcodes.json'

  DECODING_REPLACEMENT_START_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_START__'
  DECODING_REPLACEMENT_END_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_END__'
  EXECUTION_REPLACEMENT_START_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_START__'
  EXECUTION_REPLACEMENT_END_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_END__'
  TESTS_REPLACEMENT_START_PATTERN = '// __TESTS_REPLACEMENT_START__'
  TESTS_REPLACEMENT_END_PATTERN = '// __TESTS_REPLACEMENT_END__'

  def initialize(opcodes_file, cpu_file, tests_file)
    @opcodes_file = opcodes_file
    @cpu_file = cpu_file
    @tests_file = tests_file
  end

  def execute(only_opcode: nil)
    check_instructions_data
    download_json_page_content if !File.exists?(@opcodes_file)
    json_page_content = find_and_read_json_page_content
    json_data = JSON.parse(json_page_content)
    cpu_decoding_code, cpu_execution_code, tests_code = generate_templates(json_data, only_opcode: only_opcode)
    insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
  end

  def check_instructions_data
    opcodes_count = INSTRUCTIONS_DATA
      .values
      .flat_map { |instruction_data| instruction_data.fetch(:opcodes) }
      .each_with_object({}) { |opcode, count| count[opcode] ||= 0; count[opcode] += 1 } # tally() on Ruby 2.7

    duplicated_opcodes = opcodes_count.select { |_, count| count > 1}

    if duplicated_opcodes.size > 0
      duplicated_opcodes_hex = duplicated_opcodes.keys.map { |opcode| hex(opcode) }
      raise "Found duplicated opcodes!: #{duplicated_opcodes_hex}"
    end
  end

  def download_json_page_content
    page_content = open(OPCODES_ADDRESS).read
    prettified_data = JSON.pretty_generate(JSON.parse(page_content))
    IO.write(@opcodes_file, prettified_data)
  end

  def find_and_read_json_page_content
    IO.read(@opcodes_file)
  end

  # For samples, see the corresponding `.md` document.
  #
  def generate_templates(json_data, only_opcode:)
    decoding_generator = CpuDecodingTemplateGenerator.new
    execution_generator = CpuExecutionTemplatesGenerator.new
    tests_generator = TestTemplatesGenerator.new

    # Instruction data is mutated. Due to the Proc stored, there's no trivial solution to perform a
    # deep clone; since the data is consumed only once, keeping the worklflow simple is an acceptable
    # solution.
    #
    INSTRUCTIONS_DATA.each do |opcode_family, instruction_data|
      opcodes = instruction_data.fetch(:opcodes)

      next if only_opcode && !opcodes.include?(only_opcode)

      opcode_family_encoded = opcode_family
        .gsub(/\((\w+)\)/, 'I\1')               # indirect:        `(HL)` -> `IHL`
        .gsub(/\(\$(\w+) \+ (\w)\)/, 'I_\1_\2') # Indirect+displ.: `($FF00 + C)` -> I_FF00_C
        .gsub(/,? /, "_")

      prefixed_json_entry = instruction_data.fetch(:prefixed) ? "prefixed" : "unprefixed"

      transform_opcode_data = instruction_data[:transform_opcode_data]

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        transform_opcode_data&.(opcode_data)

        # This procedure is essentially a denormalization of the (extra) instruction data.
        #
        extra_instruction_data = extract_instructions_data_from_opcode_data(opcode_data)
        checked_copy_extra_instruction_data!(opcode, extra_instruction_data, instruction_data)
      end

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        decoding_generator.add_code!(opcode, opcode_family_encoded, opcode_data, instruction_data)
        tests_generator.add_code!(opcode, opcode_family, opcode_data, instruction_data)
      end

      execution_generator.add_code!(opcode_family_encoded, instruction_data)
    end

    # Remove the trailing empty line, if any.
    #
    [decoding_generator, execution_generator, tests_generator].map { |generator| generator.code.sub(/^\n\Z/, '') }
  end

  def insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
    cpu_file_content = IO.read(@cpu_file)

    new_cpu_file_content = cpu_file_content
      .sub(/^( *#{DECODING_REPLACEMENT_START_PATTERN}\n).*(^ *#{DECODING_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_decoding_code}\\2")
      .sub(/^( *#{EXECUTION_REPLACEMENT_START_PATTERN}\n).*(^ *#{EXECUTION_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_execution_code}\\2")

    IO.write(@cpu_file, new_cpu_file_content)

    tests_file_content = IO.read(@tests_file)

    new_tests_file_content = tests_file_content
      .sub(/^( *#{TESTS_REPLACEMENT_START_PATTERN}\n).*(^ *#{TESTS_REPLACEMENT_END_PATTERN})/m, "\\1#{tests_code}\\2")

    IO.write(@tests_file, new_tests_file_content)
  end

  ##################################################################################################
  # DATA MANIPULATION
  ##################################################################################################

  # Returns [flags_data, instruction_size, operand_types].
  #
  def extract_instructions_data_from_opcode_data(opcode_data)
    flags_data = opcode_data.fetch("flags")
    instruction_size = opcode_data.fetch("bytes")
    operands_data = opcode_data.fetch("operands")

    # WATCH OUT!! The JSON gets the "immediate" metadata wrong; the correct semantic is is the
    # opposite (see https://git.io/JU8JY).
    #
    operand_types = operands_data.map do |operand_data|
      operand_name = operand_data.fetch("name")

      case operand_name
      when "d8"
        IMMEDIATE_OPERAND
      when "a16"
        INDIRECT_IMMEDIATE_OPERAND
      when /\w \+ [0-9A-F]/
        INDIRECT_IMMEDIATE_REGISTER_OPERAND
      when *REGISTERS_8B
        REGISTER_OPERAND
      when *REGISTERS_16B
        INDIRECT_REGISTER_OPERAND
      else
        debugger
        raise("Unsupported operand type for opcode %02X: #{operand_data}" % opcode)
      end
    end

    {
      flags_data: flags_data,
      instruction_size: instruction_size,
      operand_types: operand_types,
    }
  end

  def checked_copy_extra_instruction_data!(opcode, extra_instruction_data, instruction_data)
    if !instruction_data.key?(:flags_data)
      instruction_data.merge!(extra_instruction_data)
    else
      subset_instruction_data = instruction_data.slice(:flags_data, :instruction_size, :operand_types)

      if extra_instruction_data != subset_instruction_data
        puts "Opcode: #{hex(opcode)}"
        puts "EXISTING: #{subset_instruction_data}"
        puts "CURRENT:  #{extra_instruction_data}"
        debugger
        raise "Mismatching family data!"
      end
    end
  end
end

module CommandlineDecoder
  extend self

  def execute
    if (ARGV & %w[-h --help]).size > 0
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 0
    elsif ARGV.size > 1
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 1
    else
      opcode = ARGV[0]&.hex
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  opcodes_file = File.expand_path("opcodes.json", __dir__)
  cpu_file = File.expand_path("../../component_sharp_lr35902/src/cpu.rs", __dir__)
  tests_file = File.expand_path("../../component_sharp_lr35902/src/cpu_test.rs", __dir__)

  GitHelpers.restore_files(cpu_file, tests_file)

  only_opcode = CommandlineDecoder.execute

  CpuTemplatesGenerator.new(opcodes_file, cpu_file, tests_file).execute(only_opcode: only_opcode)
end
