#!/usr/bin/env ruby

require 'byebug'
require 'shellwords'
require 'json'
require 'open-uri'

module GitHelpers
  extend self

  def restore_files(*files)
    command = "git checkout HEAD -- " + files.map { |file| file.shellescape }.join(" ")
    execute command
  end

  private

  def execute(command)
    success = system(command)

    exit $CHILD_STATUS.exitstatus if !success
  end
end

module FormattingHelpers
  def hex(value)
    "0x%02X" % value
  end
end

module InstructionsData
  include FormattingHelpers

  extend self

  REGISTER_OPERAND = :register
  IMMEDIATE_OPERAND = :immediate
  INDIRECT_REGISTER_OPERAND = :indirect_register
  INDIRECT_IMMEDIATE_OPERAND = :indirect_immediate

  REGISTERS_8B = %w[A B C D E H L]
  REGISTERS_16B = %w[BC DE HL]

  # Code generated is not efficient, in a few ways. This can be optimized, but it's not the scope of
  # this tool.

  # Specifications:
  #
  # ## Predefined data
  #
  # - operation_code:        (optional) if `zf` is set, then a boolean variable called `carry` must be set
  # - flags_code:            (optional)
  # - operand_types:         Array of REGISTER_OPERAND, IMMEDIATE_OPERAND, INDIRECT_REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND
  # - transform_opcode_data: (optional) Executed after fetching the opcode data from the JSON; destructive.
  # - testing:               Proc taking (*operands), returns {:extra_instruction_bytes, :data_preset, :register_expectation}
  #
  # ## Computed data
  #
  # - instruction_size
  # - flags_data
  #
  # Pan doc groups some instructions that have different operand types together, e.g. `LD r1, r2`,
  # `LD r, n`, `LD r1, (r2)` and so on; this is correct in a way, but we need more a more specific
  # taxonomy, so the families as represented here are more granular.
  #
  INSTRUCTIONS_DATA = {
    "LD r, n" => {
      prefixed: false,
      opcodes: [0x06, 0x0E, 0x16, 0x1E, 0x26, 0x2E],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register, _) {
        {
          extra_instruction_bytes: [0x21],
          register_expectation: "#{register}: 0x00 => 0x21,"
        }
      }
    },
    "LD r1, r2" => {
      prefixed: false,
      opcodes: [
        0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x41, 0x42, 0x43, 0x44, 0x45, 0x48,
        0x4A, 0x4B, 0x4C, 0x4D, 0x50, 0x51, 0x53, 0x54, 0x55, 0x58, 0x59, 0x5A,
        0x5C, 0x5D, 0x60, 0x61, 0x62, 0x63, 0x65, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(register1, register2) {
        {
          data_preset: "cpu.#{register2} = 0x21;",
          register_expectation: "#{register1}: 0x00 => 0x21,",
        }
      }
    },
    "LD r1, (r2)" => {
      prefixed: false,
      opcodes: [
        0x46, 0x4E, 0x56, 0x5E, 0x66, 0x6E, 0x7E, 0x0A, 0x1A
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "LD (r1), r2" => {
      prefixed: false,
      opcodes: [
        0x70, 0x71, 0x72, 0x73, 0x74, 0x75
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    # No-ops. They are troublesome because without special handling, the register variable is
    # simultaneously borrowed as readonly and mutable, causing an error. There isn't a general way
    # of solving this, without introducing conditional logic.
    #
    "LD r, r" => {
      prefixed: false,
      opcodes: [
        0x7F, 0x40, 0x49, 0x52, 0x5B, 0x64, 0x6D
      ],
      transform_opcode_data: ->(data) do
        data.fetch("operands").pop
      end,
      operation_code: <<~RUST,
        *operand = *operand;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "LD (r), n" => {
      prefixed: false,
      opcodes: [
        0x36
      ],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "LD A, (nn)" => {
      prefixed: false,
      opcodes: [0xFA],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "LD A, n" => {
      prefixed: false,
      opcodes: [0x3E],
      operation_code: <<~RUST,
        *operand = value;
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "INC r" => {
      prefixed: false,
      opcodes: [0x3C, 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C],
      operation_code: <<~RUST,
        let (new_value, carry) = operand.overflowing_add(1);
        *operand = new_value;
      RUST
      flags_code: <<~RUST,
        if *operand & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!")],
        }
      }
    },
    "INC (HL)" => {
      prefixed: false,
      opcodes: [0x34],
      operation_code: <<~RUST,
        let (new_value, carry) = operand.overflowing_add(1);
        *operand = new_value;
      RUST
      flags_code: <<~RUST,
        if *operand & 0b0000_1111 == 0b000_0000 {
          *hf = true;
        }
      RUST
      testing: ->(*operands) {
        {
          register_expectation: %Q[// todo!("Write opcode testing metadata!");],
        }
      }
    },
    "NOP" => {
      prefixed: false,
      opcodes: [0x00],
      testing: -> { {} }
    },
  }
end

class CpuDecodingTemplateGenerator
  include InstructionsData
  include FormattingHelpers

  def initialize
    @buffer = StringIO.new
  end

  # While the instructions could be decoded algorithmically up to a certain extent, it's not worth
  # the complexity. For example, `PUSH nn` and `INC nn` use different bitmasks for the registers
  # (the 4th argument shares the same bitmask (base + 11), but point to different registers in the
  # two cases).

  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    opcode_hex = "%02X" % opcode
    operand_types = instruction_data.fetch(:operand_types)
    operand_names = opcode_data.fetch("operands").map { |data| data["name"] }

    generate_matcher_line!(opcode_hex, operand_types)
    generate_variable_assignments!(opcode_data, operand_types, operand_names)
    generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    generate_closure!(opcode_data, opcode_hex)
  end

  def code
    @buffer.string
  end

  private

  # Matcher line. Example:
  #
  #     [0x36, value @ _] => {
  #
  def generate_matcher_line!(opcode_hex, operand_types)
    @buffer.print "            [0x#{opcode_hex}"

    case operand_types
    when []
      # Nothing
    when [REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND]
      # Nothing
    when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", value @ _"
    when [REGISTER_OPERAND, REGISTER_OPERAND]
      # Nothing
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
      @buffer.print ", low_byte @ _, high_byte @ _"
    when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
      # Nothing
    when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", value @ _"
    else
      # This is for safety; it's easy to miss a tuple.
      #
      raise "Unrecognized operand types: #{operand_types}"
    end

    @buffer.puts "] => {"
  end

  # Optional variables assigned before invoking the execution code. Example:
  #
  #     let address = Self::compose_address(*high_byte, *low_byte);
  #
  def generate_variable_assignments!(opcode_data, operand_types, operand_names)
    operand_types.each_with_index do |operand_type, i|
      case operand_type
      when INDIRECT_IMMEDIATE_OPERAND
        @buffer.puts "                let address = Self::compose_address(*high_byte, *low_byte);"
        break
      when INDIRECT_REGISTER_OPERAND
        high_byte_register, low_byte_register = operand_names[i].chars
        @buffer.puts "                let address = Self::compose_address(self.#{high_byte_register}, self.#{low_byte_register});"
        break
      end
    end
  end

  # Execution method call. Example:
  #
  #     Self::execute_LD_nn_n(&mut self.PC, &mut self.B, *value);
  #
  def generate_execution_method_call!(opcode_family, instruction_data, operand_types, operand_names)
    operand_params =
      case operand_types
      when []
        # Nothing
      when [REGISTER_OPERAND]
        "&mut self.#{operand_names[0]}"
      when [INDIRECT_REGISTER_OPERAND]
        "&mut self.internal_ram[address]"
      when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "*value"
        ]
      when [REGISTER_OPERAND, REGISTER_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.#{operand_names[1]}"
        ]
      when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.internal_ram[address]"
        ]
      when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
        [
          "&mut self.#{operand_names[0]}",
          "self.internal_ram[address]"
        ]
      when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
        [
          "&mut self.internal_ram[address]",
          "self.#{operand_names[1]}"
        ]
      when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
        [
          "&mut self.internal_ram[address]",
          "*value"
        ]
      else
        raise "Unrecognized operand types: #{operand_types}"
      end

    flag_params = instruction_data.fetch(:flags_data).each_with_object([]) do |(flag, state), flag_params|
      case state
      when "0", "1", flag
        flag_params << "&mut self.#{flag.downcase}f"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    all_execution_params = ["&mut self.PC", *operand_params, *flag_params].join(", ")

    @buffer.puts "                Self::execute_#{opcode_family}(#{all_execution_params});"
  end

  # Closure (cycles and closing brace)
  #
  def generate_closure!(opcode_data, opcode_hex)
    cycles = opcode_data.fetch("cycles")[0] || raise("Missing #{opcode_hex} cycles!")

    @buffer.puts <<-RUST
                #{cycles}
            }
    RUST
  end
end

class CpuExecutionTemplatesGenerator
  include InstructionsData

  def initialize
    @buffer = StringIO.new
  end

  def add_code!(opcode_family, instruction_data)
    generate_method_signature!(opcode_family, instruction_data)
    generate_register_operations!(instruction_data)
    generate_flag_operations!(instruction_data)
    generate_closure!
  end

  def code
    @buffer.string
  end

  private

  # Execution method call. Example:
  #
  #     fn execute_LD_r_n(PC: &mut u16, operand: &mut u8, value: u8) {
  #
  def generate_method_signature!(opcode_family, instruction_data)
    operand_types = instruction_data.fetch(:operand_types)

    @buffer.print "    fn execute_#{opcode_family}(PC: &mut u16"

    case operand_types
    when []
      # nothing to add
    when [REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8"
    when [INDIRECT_REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8"
    when [REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, INDIRECT_IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [REGISTER_OPERAND, INDIRECT_REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_REGISTER_OPERAND, REGISTER_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_IMMEDIATE_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    when [INDIRECT_REGISTER_OPERAND, IMMEDIATE_OPERAND]
      @buffer.print ", operand: &mut u8, value: u8"
    else
      raise "Unrecognized operand types: #{operand_types}"
    end

    flags_data = instruction_data.fetch(:flags_data)

    flags_data.each do |flag, state|
      case state
      when "0", "1", flag
        @buffer.print ", #{flag.downcase}f: &mut bool"
      when "-"
        # ignore
      else
        raise "Invalid flag state: #{state}"
      end
    end

    @buffer.puts ") {"
  end

  # Operations involving registers. Example:
  #
  #     *PC += 1;
  #
  #     let (new_value, carry) = operand.overflowing_add(1);
  #     *operand = new_value;
  #
  def generate_register_operations!(instruction_data)
    instruction_size = instruction_data.fetch(:instruction_size)

    @buffer.puts <<-RUST
      *PC += #{instruction_size};

    RUST

    operation_code = instruction_data[:operation_code]

    if operation_code
      operation_code.each_line do |operation_statement|
        @buffer.puts "      #{operation_statement}"
      end
      @buffer.puts
    end
  end

  # Operations involving flags. Example:
  #
  #     if carry {
  #       *zf = true;
  #     }
  #     *nf = false;
  #
  def generate_flag_operations!(instruction_data)
    flags_code = instruction_data[:flags_code]

    if flags_code
      flags_code.each_line do |flag_statement|
        @buffer.print "      #{flag_statement}"
      end
    end

    flags_data = instruction_data.fetch(:flags_data)

    flags_data.each do |flag, state|
      case state
      when "0"
        @buffer.puts "      *#{flag.downcase}f = false;"
      when "1"
        @buffer.puts "      *#{flag.downcase}f = true;"
      when flag
        if flag == "Z"
          @buffer.puts <<-RUST
      if carry {
        *zf = true;
      }
          RUST
        else
          # Make sure the operation code takes care of it!
          #
          raise "Missing #{opcode_family} #{flag} flag setting!" if flags_code !~ /\*#{flag.downcase}f = /
        end
      when "-"
        # do nothing
      else
        raise "Invalid flag state: #{state}"
      end
    end
  end

  # Closing brace.
  #
  def generate_closure!
    @buffer.puts <<-RUST
    }

    RUST
  end
end

class TestTemplatesGenerator
  include FormattingHelpers

  def initialize
    @buffer = StringIO.new
  end

  # This is a bit annoying, because in some cases there is a context, and in some there isn't.
  #
  def add_code!(opcode, opcode_family, opcode_data, instruction_data)
    generate_header!(opcode, opcode_data, instruction_data)

    if modified_flags(instruction_data).size > 0
      test_padding = " " * 4
    end

    # Main test
    #
    generate_test_body!(opcode, opcode_data, instruction_data, nil, test_padding)

    # Flag tests (invokes :generate_test_body!)
    #
    generate_flag_tests!(opcode, opcode_data, instruction_data, test_padding)

    generate_closure!(instruction_data)
  end

  def code
    @buffer.string
  end

  private

  # "Header": Context (optional), and main test method.
  #
  # `context`, or `it` depending on flags being changed or not
  #
  def generate_header!(opcode, opcode_data, instruction_data)
    opcode_mnemonic = opcode_data.fetch("mnemonic")
    opcode_operands = opcode_data.fetch("operands").map { |data| data.fetch("name") }

    main_block_title = "#{opcode_mnemonic} #{opcode_operands.join(", ")} (#{hex(opcode)})"

    if modified_flags(instruction_data).empty?
      @buffer.puts %Q[            it "#{main_block_title}" {]
    else
      @buffer.puts %Q[            context "#{main_block_title}" {]
      @buffer.puts %Q(                it "without flags modified" {)
    end
  end

  # Adding straight `todo!()` in uncommented form causes a few troubles, and it's not worth the
  # hassle.
  #
  def generate_test_body!(opcode, opcode_data, instruction_data, flag_expectation, pad)
    opcode_operands = opcode_data.fetch("operands").map { |data| data.fetch("name") }
    testing_block = instruction_data.fetch(:testing)

    extra_instruction_bytes, data_preset, register_expectation = testing_block
      .(*opcode_operands)
      .values_at(:extra_instruction_bytes, :data_preset, :register_expectation)

    extra_instruction_bytes_str = extra_instruction_bytes.to_a.map { |byte| ", #{hex(byte)}" }.join

    @buffer.print <<-RUST
#{pad}                let instruction_bytes = [#{hex(opcode)}#{extra_instruction_bytes_str}];
    RUST

    data_preset.to_s.each_line.each_with_index do |preset_statement, i|
      @buffer.puts if i == 0
      @buffer.print <<-RUST
#{pad}                #{preset_statement.strip}
      RUST
    end

    @buffer.print <<-RUBY.gsub(/^(?!$)/, "#{pad}")

                assert_cpu_execute!(
                    cpu,
                    instruction_bytes,
    RUBY

    instruction_size = instruction_data.fetch(:instruction_size)
    start_pc = 0x21
    end_pc = start_pc + instruction_size
    cycles = opcode_data.fetch("cycles")[0]

    pc_expectation = "PC: #{hex(start_pc)} => #{hex(end_pc)},"

    # The memory expectation is technically a register expectation, but needs to go before the flags,
    # so we need to perform sorting.
    #
    # Note that we compact(), since the register expectation is optional.
    #
    all_register_expectations = [register_expectation, pc_expectation].compact.sort_by do |expectation|
      expectation.start_with?('mem[') ? 1 : -1
    end

    all_register_expectations.each do |expectation|
      @buffer.puts "#{pad}                    #{expectation}"
    end

    @buffer.puts "#{pad}                    #{flag_expectation}" if flag_expectation

    @buffer.print <<-RUBY.gsub(/^(?!$)/, "#{pad}")
                    cycles: #{cycles}
                );
            }
    RUBY
  end

  def generate_flag_tests!(opcode, opcode_data, instruction_data, test_padding)
    modified_flags(instruction_data).each do |flag, state|
      flag_expectation =
        case state
        when "0"
          "#{flag.downcase}f: 1 => 0,"
        when "1"
          "#{flag.downcase}f: 0 => 1,"
        when flag
          %Q(// todo!("Flag #{flag.downcase}f"),)
        else
          raise "Unrecognized state: #{state}"
        end

      @buffer.print <<-RUBY

                it "with flag #{flag} modified" {
      RUBY

      generate_test_body!(opcode, opcode_data, instruction_data, flag_expectation, test_padding)
    end
  end

  # Optional closing brace (if there was a context).
  #
  def generate_closure!(instruction_data)
    if !modified_flags(instruction_data).empty?
      @buffer.puts "            }"
    end

    @buffer.puts
  end

  ##################################################################################################
  # HELPERS
  ##################################################################################################

  # Returns {"flag" => "state" }.
  #
  def modified_flags(instruction_data)
    instruction_data.fetch(:flags_data).select { |flag, state| state == "0" || state == "1" || flag == state }
  end
end

class CpuTemplatesGenerator
  include InstructionsData

  OPCODES_ADDRESS = 'https://gbdev.io/gb-opcodes/Opcodes.json'

  DECODING_REPLACEMENT_START_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_START__'
  DECODING_REPLACEMENT_END_PATTERN = '// __OPCODES_DECODING_REPLACEMENT_END__'
  EXECUTION_REPLACEMENT_START_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_START__'
  EXECUTION_REPLACEMENT_END_PATTERN = '// __OPCODES_EXECUTION_REPLACEMENT_END__'
  TESTS_REPLACEMENT_START_PATTERN = '// __TESTS_REPLACEMENT_START__'
  TESTS_REPLACEMENT_END_PATTERN = '// __TESTS_REPLACEMENT_END__'

  def initialize(opcodes_file, cpu_file, tests_file)
    @opcodes_file = opcodes_file
    @cpu_file = cpu_file
    @tests_file = tests_file
  end

  def execute(only_opcode: nil)
    check_instructions_data
    download_json_page_content if !File.exists?(@opcodes_file)
    json_page_content = find_and_read_json_page_content
    json_data = JSON.parse(json_page_content)
    cpu_decoding_code, cpu_execution_code, tests_code = generate_templates(json_data, only_opcode: only_opcode)
    insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
  end

  def check_instructions_data
    opcodes_count = INSTRUCTIONS_DATA
      .values
      .flat_map { |instruction_data| instruction_data.fetch(:opcodes) }
      .each_with_object({}) { |opcode, count| count[opcode] ||= 0; count[opcode] += 1 } # tally() on Ruby 2.7

    duplicated_opcodes = opcodes_count.select { |_, count| count > 1}

    if duplicated_opcodes.size > 0
      duplicated_opcodes_hex = duplicated_opcodes.keys.map { |opcode| hex(opcode) }
      raise "Found duplicated opcodes!: #{duplicated_opcodes_hex}"
    end
  end

  def download_json_page_content
    page_content = open(OPCODES_ADDRESS).read
    prettified_data = JSON.pretty_generate(JSON.parse(page_content))
    IO.write(@opcodes_file, prettified_data)
  end

  def find_and_read_json_page_content
    IO.read(@opcodes_file)
  end

  # For samples, see the corresponding `.md` document.
  #
  def generate_templates(json_data, only_opcode:)
    decoding_generator = CpuDecodingTemplateGenerator.new
    execution_generator = CpuExecutionTemplatesGenerator.new
    tests_generator = TestTemplatesGenerator.new

    # Instruction data is mutated. Due to the Proc stored, there's no trivial solution to perform a
    # deep clone; since the data is consumed only once, keeping the worklflow simple is an acceptable
    # solution.
    #
    INSTRUCTIONS_DATA.each do |opcode_family, instruction_data|
      opcodes = instruction_data.fetch(:opcodes)

      next if only_opcode && !opcodes.include?(only_opcode)

      opcode_family_encoded = opcode_family
        .gsub(/\((\w+)\)/, 'I\1')
        .gsub(/,? /, "_")

      prefixed_json_entry = instruction_data.fetch(:prefixed) ? "prefixed" : "unprefixed"

      transform_opcode_data = instruction_data[:transform_opcode_data]

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        transform_opcode_data&.(opcode_data)

        # This procedure is essentially a denormalization of the (extra) instruction data.
        #
        extra_instruction_data = extract_instructions_data_from_opcode_data(opcode_data)
        checked_copy_extra_instruction_data!(opcode, extra_instruction_data, instruction_data)
      end

      opcodes.each do |opcode|
        next if only_opcode && opcode != only_opcode

        opcode_data = json_data.fetch(prefixed_json_entry).fetch(hex(opcode))

        decoding_generator.add_code!(opcode, opcode_family_encoded, opcode_data, instruction_data)
        tests_generator.add_code!(opcode, opcode_family, opcode_data, instruction_data)
      end

      execution_generator.add_code!(opcode_family_encoded, instruction_data)
    end

    # Remove the trailing empty line, if any.
    #
    [decoding_generator, execution_generator, tests_generator].map { |generator| generator.code.sub(/^\n\Z/, '') }
  end

  def insert_content_in_source_files(cpu_decoding_code, cpu_execution_code, tests_code)
    cpu_file_content = IO.read(@cpu_file)

    new_cpu_file_content = cpu_file_content
      .sub(/^( *#{DECODING_REPLACEMENT_START_PATTERN}\n).*(^ *#{DECODING_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_decoding_code}\\2")
      .sub(/^( *#{EXECUTION_REPLACEMENT_START_PATTERN}\n).*(^ *#{EXECUTION_REPLACEMENT_END_PATTERN}\n)/m, "\\1#{cpu_execution_code}\\2")

    IO.write(@cpu_file, new_cpu_file_content)

    tests_file_content = IO.read(@tests_file)

    new_tests_file_content = tests_file_content
      .sub(/^( *#{TESTS_REPLACEMENT_START_PATTERN}\n).*(^ *#{TESTS_REPLACEMENT_END_PATTERN})/m, "\\1#{tests_code}\\2")

    IO.write(@tests_file, new_tests_file_content)
  end

  ##################################################################################################
  # DATA MANIPULATION
  ##################################################################################################

  # Returns [flags_data, instruction_size, operand_types].
  #
  def extract_instructions_data_from_opcode_data(opcode_data)
    flags_data = opcode_data.fetch("flags")
    instruction_size = opcode_data.fetch("bytes")
    operands_data = opcode_data.fetch("operands")

    # WATCH OUT!! The JSON gets the "immediate" metadata wrong; the correct semantic is is the
    # opposite (see https://git.io/JU8JY).
    #
    operand_types = operands_data.map do |operand_data|
      operand_name = operand_data.fetch("name")

      case operand_name
      when "d8"
        IMMEDIATE_OPERAND
      when "a16"
        INDIRECT_IMMEDIATE_OPERAND
      when *REGISTERS_8B
        REGISTER_OPERAND
      when *REGISTERS_16B
        INDIRECT_REGISTER_OPERAND
      else
        debugger
        raise("Unsupported operand type for opcode %02X: #{operand_data}" % opcode)
      end
    end

    {
      flags_data: flags_data,
      instruction_size: instruction_size,
      operand_types: operand_types,
    }
  end

  def checked_copy_extra_instruction_data!(opcode, extra_instruction_data, instruction_data)
    if !instruction_data.key?(:flags_data)
      instruction_data.merge!(extra_instruction_data)
    else
      subset_instruction_data = instruction_data.slice(:flags_data, :instruction_size, :operand_types)

      if extra_instruction_data != subset_instruction_data
        puts "Opcode: #{hex(opcode)}"
        puts "EXISTING: #{subset_instruction_data}"
        puts "CURRENT:  #{extra_instruction_data}"
        debugger
        raise "Mismatching family data!"
      end
    end
  end
end

module CommandlineDecoder
  extend self

  def execute
    if (ARGV & %w[-h --help]).size > 0
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 0
    elsif ARGV.size > 1
      puts "Usage: #{File.basename($PROGRAM_NAME)} [0x<opcode_hex>]"
      exit 1
    else
      opcode = ARGV[0]&.hex
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  opcodes_file = File.expand_path("opcodes.json", __dir__)
  cpu_file = File.expand_path("../../component_sharp_lr35902/src/cpu.rs", __dir__)
  tests_file = File.expand_path("../../component_sharp_lr35902/src/cpu_test.rs", __dir__)

  GitHelpers.restore_files(cpu_file, tests_file)

  only_opcode = CommandlineDecoder.execute

  CpuTemplatesGenerator.new(opcodes_file, cpu_file, tests_file).execute(only_opcode: only_opcode)
end
